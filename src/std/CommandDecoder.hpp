#pragma once

#include "std/Array.hpp"
#include "std/Slice.hpp"
#include "std/Types.h"
#include "std/Vector.hpp"

/** @file CommandDecoder.hpp */

/**
 * \defgroup DeltaEncoding Delta encoding
 * @{
 */

/**
 * \brief A decoder for a delta-encoded command stream generated by
 * CommandEncoder.
 *
 * \tparam FieldEnum An enum type with enumerations for every independent
 * command field.
 *
 * \see CommandEncoder
 */
template <typename FieldEnum>
struct CommandDecoder {
  /**
   * \param encoded The output of a CommandEncoder.
   */
  CommandDecoder(Slice<const u8> encoded) : _buffer(encoded) {}

  bool isOver() const noexcept { return _buffer.length == 0; }

 protected:
  u32 _dirtyMask = 0;
  Slice<const u8> _buffer;

  Array<FieldEnum, 32> bufChanges;
  Vector<FieldEnum> changes;

  /**
   * \brief Begins the decoding of the next command.
   * \returns `false` if the stream has ended.
   */
  bool beginNextDecode() noexcept {
    if (_buffer.length < sizeof(u32)) {
      return false;
    }
    read(_dirtyMask);
    changes = {bufChanges.data, 0, 32};
    return true;
  }

  /**
   * \brief Reads the LSB from the dirty mask and right shifts the mask by one.
   * If the bit was set, it reads a value of `T` from the byte stream and pushes
   * `DF` into the list of changed fields.
   */
  template <FieldEnum DF, typename T>
  void readIfFlag(T &val) noexcept {
    if ((_dirtyMask & 1) == 0) {
      _dirtyMask >>= 1;
      return;
    }

    read(val);
    *append(nullptr, &changes) = DF;
    _dirtyMask >>= 1;
  }

  /**
   * \brief For each element of the array, it reads the LSB from the dirty mask
   * and right shifts the mask by one; then if the bit was set, it reads a value
   * of `T` from the byte stream, writes it to arr[i] and pushes `DF + i` into
   * the list of changed fields.
   */
  template <FieldEnum DF, size_t N, typename T>
  void readIfFlag(Array<T, N> &arr) noexcept {
    for (u32 i = 0; i < N; i++) {
      if (_dirtyMask & 1) {
        read(arr[i]);
        *append(nullptr, &changes) = FieldEnum(DF + i);
      }

      _dirtyMask >>= 1;
    }
  }

  /**
   * \brief Reads the LSB from the dirty mask and right shifts the mask by one.
   * If the bit was set, it reads an array of `T` from the byte stream and
   * pushes `DF` into the list of changed fields.
   */
  template <FieldEnum DF, size_t N, typename T>
  void readIfFlagWhole(Array<T, N> &arr) noexcept {
    if (_dirtyMask & 1) {
      for (u32 i = 0; i < N; i++) {
        read(arr[i]);
      }

      *append(nullptr, &changes) = DF;
    }
    _dirtyMask >>= 1;
  }

  template <typename T>
  bool tryRead(T &out) {
    if (_buffer.length < sizeof(T)) {
      return false;
    }

    out = _buffer.subarray(0, sizeof(T)).cast<const T>()[0];

    shrinkFromLeftByCount(&_buffer, sizeof(T));
    return true;
  }

  template <typename T>
  void read(T &out) {
    bool res = tryRead(out);
    DCHECK(res);
  }

  /**
   * \brief Returns the list of fields that have changed since the last
   * command. The returned list is only valid if a `readIf*` function call has
   * been made for every field of the command type.
   */
  Slice<FieldEnum> getChangeList() const noexcept {
    return {changes.data, changes.length};
  }
};

/**@}*/
